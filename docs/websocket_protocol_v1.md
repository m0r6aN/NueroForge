
# NeuroForge WebSocket Protocol v1 (Phase 1 - Behavioral Metrics)

## Overview

This document defines the initial WebSocket message format for sending basic user behavioral metrics from the frontend client to the backend server for analysis and future integration into the cognitive state model.

## Connection

-   Clients connect to the WebSocket endpoint provided by the backend (e.g., `wss://yourdomain.com/ws` or `ws://localhost:5001/ws` for dev).
-   Authentication: The initial connection should ideally be authenticated. This can be achieved by passing the user's API JWT as a query parameter during the WebSocket connection handshake (e.g., `wss://yourdomain.com/ws?token=YOUR_JWT_HERE`). The backend server must verify this token upon connection.

## Message Format

-   All messages from Client to Server are JSON strings.
-   Each message object MUST contain a `type` field indicating the nature of the event.
-   Each message object SHOULD contain a `timestamp` field (ISO 8601 string) generated by the client.
-   Additional payload fields depend on the message `type`.

## Message Types (Client -> Server)

### 1. `session_start`

-   **Purpose:** Sent when a user begins a distinct learning session or activity where tracking is relevant (e.g., starting a lesson, beginning a review session).
-   **Payload:**
    -   `context`: Object containing details about the current activity.
        -   `type`: String (e.g., `"lesson"`, `"review_session"`, `"focus_exercise"`)
        -   `id`: String (e.g., `lessonId`, `subjectId`, unique session ID)
        -   `title`: String (Optional, e.g., Lesson title)

```json
{
  "type": "session_start",
  "timestamp": "2024-08-06T10:00:00.123Z",
  "payload": {
    "context": {
      "type": "lesson",
      "id": "64cbe7a5b123456789abcdef0",
      "title": "Introduction to Quantum Physics"
    }
  }
}
```

### 2. `session_end`

-   **Purpose:** Sent when a user explicitly ends or navigates away from a tracked session.
-   **Payload:**
    -   `context`: Object matching the `session_start` context.
    *   `durationSeconds`: Number (Calculated duration of the session on the client).

```json
{
  "type": "session_end",
  "timestamp": "2024-08-06T10:15:30.456Z",
  "payload": {
    "context": {
      "type": "lesson",
      "id": "64cbe7a5b123456789abcdef0"
    },
    "durationSeconds": 930.333
  }
}
```

### 3. `interaction`

-   **Purpose:** Sent for significant user interactions within a session. Granularity can be adjusted later. Initial focus on basic engagement.
-   **Payload:**
    -   `context`: Object matching the current session context.
    *   `interactionType`: String (e.g., `"click"`, `"scroll_deep"`, `"answer_submit"`, `"focus_timer_start"`, `"audio_preset_change"`)
    *   `details`: Object (Optional, context-specific details)
        -   e.g., for `"answer_submit"`: `{ questionId: "q1", correct: true }`
        -   e.g., for `"audio_preset_change"`: `{ preset: "focus", volume: 0.6 }`

```json
{
  "type": "interaction",
  "timestamp": "2024-08-06T10:05:15.789Z",
  "payload": {
    "context": {
      "type": "lesson",
      "id": "64cbe7a5b123456789abcdef0"
    },
    "interactionType": "answer_submit",
    "details": { "questionId": "q1", "correct": true }
  }
}
```

### 4. `focus_change` (Future Phase 1 refinement or Phase 2)

-   **Purpose:** Sent when browser visibility changes (tab switch away/back). Useful for inferring focus breaks.
-   **Payload:**
    -   `context`: Object matching the current session context.
    *   `status`: String (`"focused"` or `"unfocused"`)

```json
{
  "type": "focus_change",
  "timestamp": "2024-08-06T10:10:05.000Z",
  "payload": {
    "context": {
      "type": "lesson",
      "id": "64cbe7a5b123456789abcdef0"
    },
    "status": "unfocused"
  }
}
```

## Server -> Client Messages (Phase 1 - Minimal)

-   Initially, the server might only send simple acknowledgments or error messages if needed, but the primary flow is Client -> Server data collection. Bi-directional control can be added later.
-   Example Error:
    ```json
    { "type": "error", "message": "Invalid message format" }
    ```

## Versioning

-   This is Protocol v1. Future changes should increment the version and maintain backward compatibility where possible or require client updates.

---

**Phase 2: Frontend WebSocket Client Implementation Outline & Initial Setup**

*(Creating/Updating Frontend Files)*

**File:** `neuroforge/frontend/hooks/useWebSocket.ts` (New File)

```typescript
// neuroforge/frontend/hooks/useWebSocket.ts
import { useState, useEffect, useRef, useCallback } from 'react';
import { useSession } from 'next-auth/react';
import { toast } from '@/components/ui/use-toast'; // For connection status/errors

// Define message types based on protocol doc
// TODO: Create proper types/interfaces in `types/websocket.ts`
type WebSocketMessagePayload = any; // Placeholder

const WEBSOCKET_URL = process.env.NEXT_PUBLIC_WEBSOCKET_URL || 'ws://localhost:5001/ws'; // Get URL from env

export enum WebSocketStatus {
    CONNECTING = 'Connecting',
    OPEN = 'Open',
    CLOSING = 'Closing',
    CLOSED = 'Closed',
    UNINSTANTIATED = 'Uninstantiated',
}

export function useWebSocket() {
    const { data: session } = useSession();
    const [status, setStatus] = useState<WebSocketStatus>(WebSocketStatus.UNINSTANTIATED);
    const ws = useRef<WebSocket | null>(null);
    const reconnectTimeout = useRef<NodeJS.Timeout | null>(null);
    const connectAttempt = useRef<number>(0);

    const connect = useCallback(() => {
        if (!session?.accessToken) {
             console.warn('[WebSocket] No access token available, delaying connection.');
             // Optionally try again later or require login
             setStatus(WebSocketStatus.CLOSED);
            return;
        }
        if (ws.current && ws.current.readyState === WebSocket.OPEN) {
             console.log('[WebSocket] Already connected.');
            return;
        }

        // Clear any existing reconnect timeouts
        if (reconnectTimeout.current) {
            clearTimeout(reconnectTimeout.current);
            reconnectTimeout.current = null;
        }

        console.log('[WebSocket] Attempting to connect...');
        setStatus(WebSocketStatus.CONNECTING);
        connectAttempt.current += 1;

        // Append token for authentication
        const urlWithToken = `${WEBSOCKET_URL}?token=${session.accessToken}`;
        ws.current = new WebSocket(urlWithToken);

        ws.current.onopen = () => {
            console.log('[WebSocket] Connection established.');
            setStatus(WebSocketStatus.OPEN);
             toast({ title: "Neural Link Active", duration: 2000 });
             connectAttempt.current = 0; // Reset attempts on success
        };

        ws.current.onclose = (event) => {
            console.warn(`[WebSocket] Connection closed. Code: ${event.code}, Reason: ${event.reason}`);
            setStatus(WebSocketStatus.CLOSED);
            ws.current = null;

             // Implement reconnection logic with backoff
             if (connectAttempt.current < 5) { // Limit reconnect attempts
                  const delay = Math.pow(2, connectAttempt.current) * 1000; // Exponential backoff
                  console.log(`[WebSocket] Attempting reconnect in ${delay / 1000}s...`);
                  reconnectTimeout.current = setTimeout(connect, delay);
             } else {
                  console.error('[WebSocket] Max reconnect attempts reached.');
                  toast({ title: "Neural Link Severed", description: "Could not maintain connection.", variant: "destructive"});
             }
        };

        ws.current.onerror = (error) => {
            console.error('[WebSocket] Error:', error);
            // onclose will usually be called after onerror, triggering reconnect logic
             setStatus(WebSocketStatus.CLOSED); // Assume closed on error
        };

        ws.current.onmessage = (event) => {
            // Handle messages from server (e.g., acknowledgments, errors, future features)
            try {
                const message = JSON.parse(event.data);
                console.log('[WebSocket] Message from server:', message);
                // TODO: Process server messages based on type
                 if (message.type === 'error') {
                      toast({ title: "WebSocket Error", description: message.message, variant: "destructive"});
                 }
            } catch (error) {
                console.error('[WebSocket] Error parsing server message:', error);
            }
        };
    }, [session?.accessToken]); // Reconnect if token changes

    const disconnect = useCallback(() => {
        if (reconnectTimeout.current) {
            clearTimeout(reconnectTimeout.current); // Prevent reconnect attempts if manually disconnecting
            reconnectTimeout.current = null;
        }
         connectAttempt.current = 10; // Prevent automatic reconnect after manual disconnect
        if (ws.current) {
            console.log('[WebSocket] Closing connection...');
            setStatus(WebSocketStatus.CLOSING);
            ws.current.close();
            // onclose handler will set status to CLOSED and ws.current to null
        }
    }, []);

    // Effect to connect when session is available and disconnect on unmount/logout
    useEffect(() => {
        if (session?.accessToken && status !== WebSocketStatus.OPEN && status !== WebSocketStatus.CONNECTING) {
             connect();
        } else if (!session?.accessToken && status === WebSocketStatus.OPEN) {
             disconnect(); // Disconnect if user logs out
        }

        // Cleanup on component unmount
        return () => {
            disconnect();
        };
    }, [session, status, connect, disconnect]); // Added status dependency

    const sendMessage = useCallback((message: { type: string; payload: WebSocketMessagePayload }) => {
        if (ws.current && ws.current.readyState === WebSocket.OPEN) {
            try {
                const messageWithTimestamp = {
                    ...message,
                    timestamp: new Date().toISOString(),
                };
                ws.current.send(JSON.stringify(messageWithTimestamp));
                console.log('[WebSocket] Sent:', message.type, message.payload);
            } catch (error) {
                console.error('[WebSocket] Error sending message:', error);
            }
        } else {
            console.warn('[WebSocket] Cannot send message, connection not open.');
            // TODO: Implement message queueing? For now, messages are dropped if not connected.
        }
    }, []);

    return { status, sendMessage, connect, disconnect };
}
```

**File:** `neuroforge/frontend/components/providers/websocket-provider.tsx` (New File)

```typescript
// neuroforge/frontend/components/providers/websocket-provider.tsx
"use client";

import React, { createContext, useContext } from 'react';
import { useWebSocket, WebSocketStatus } from '@/hooks/useWebSocket';

interface WebSocketContextType {
    status: WebSocketStatus;
    sendMessage: (message: { type: string; payload: any }) => void;
}

const WebSocketContext = createContext<WebSocketContextType | undefined>(undefined);

export function WebSocketProvider({ children }: { children: React.ReactNode }) {
    const { status, sendMessage } = useWebSocket();

    return (
        <WebSocketContext.Provider value={{ status, sendMessage }}>
            {children}
        </WebSocketContext.Provider>
    );
}

export function useNeuroForgeWebSocket(): WebSocketContextType {
    const context = useContext(WebSocketContext);
    if (context === undefined) {
        throw new Error('useNeuroForgeWebSocket must be used within a WebSocketProvider');
    }
    return context;
}

```

**File:** `neuroforge/frontend/app/layout.tsx` (Updated)

```typescript
// neuroforge/frontend/app/layout.tsx
// ... existing imports ...
import { WebSocketProvider } from "@/components/providers/websocket-provider"; // Import Provider

export default function RootLayout({ children }: Readonly<{ children: React.ReactNode; }>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <AuthProvider> {/* SessionProvider for NextAuth */}
          <ThemeProvider /* ... theme props ... */ >
            {/* Wrap with WebSocketProvider AFTER AuthProvider */}
            <WebSocketProvider>
                {children}
                <Toaster />
            </WebSocketProvider>
            {/* --- End WebSocketProvider --- */}
          </ThemeProvider>
        </AuthProvider>
      </body>
    </html>
  );
}
```

**File:** `neuroforge/frontend/app/(app)/learn/lesson/[lessonId]/page.tsx` (Updated Example Usage)

```typescript
// neuroforge/frontend/app/(app)/learn/lesson/[lessonId]/page.tsx
// ... existing imports ...
import { useNeuroForgeWebSocket } from '@/components/providers/websocket-provider'; // Import hook

export default function LessonPage() {
    // ... existing state and hooks (params, toast, useBinauralBeats, useState, useEffect for lesson fetch) ...
    const { sendMessage, status: wsStatus } = useNeuroForgeWebSocket(); // Use the hook
    const lessonId = params?.lessonId as string; // Already getting lessonId

    // Effect to send session_start and session_end
    useEffect(() => {
         if (lessonId && lessonData && wsStatus === WebSocketStatus.OPEN) { // Only send if connected and data loaded
            // Send session start when lesson data is loaded
            sendMessage({
                type: 'session_start',
                payload: {
                    context: {
                        type: 'lesson',
                        id: lessonId,
                        title: lessonData.title, // Include title if available
                    }
                }
            });

            const startTime = Date.now();

            // Return cleanup function to send session_end on unmount/navigation
            return () => {
                const endTime = Date.now();
                const durationSeconds = (endTime - startTime) / 1000;
                sendMessage({
                    type: 'session_end',
                    payload: {
                        context: { type: 'lesson', id: lessonId },
                        durationSeconds: durationSeconds,
                    }
                });
            };
         }
    }, [lessonId, lessonData, sendMessage, wsStatus]); // Depends on loaded data and connection status


    // Example: Send interaction event on button click
    const handleSomeInteraction = () => {
         sendMessage({
             type: 'interaction',
             payload: {
                 context: { type: 'lesson', id: lessonId },
                 interactionType: 'specific_button_click',
                 details: { buttonName: 'Explain More' }
             }
         });
         // ... rest of interaction logic ...
    };


    // ... rest of component rendering ...

    return (
        // ... JSX ...
         {/* Add a button or interaction that calls handleSomeInteraction */}
         {/* <Button onClick={handleSomeInteraction}>Explain More</Button> */}
        // ... JSX ...
    );
}
```
## Message Types (Client -> Server)

### 3. `interaction`

-   **Purpose:** Sent for significant user interactions within a session.
-   **Payload:**
    -   `context`: Object matching the current session context (`{ type: 'lesson' | 'review_session' | ... , id: '...' }`).
    *   `interactionType`: String (Standardized types below).
    *   `details`: Object (Context-specific details).

#### Standardized `interactionType` Values & `details` Payloads:

*   **`srs_review_submit`**
    *   **Trigger:** User submits performance score on an SRS review card.
    *   **`details`:**
        *   `progressId`: String (ID of the `UserProgress` item being reviewed).
        *   `lessonId`: String (ID of the underlying `Lesson`).
        *   `performanceScore`: Number (0-5).
        *   `showAnswerDurationMs`: Number (Optional: Time in ms between showing answer and submitting score).

    ```json
    {
      "type": "interaction",
      "timestamp": "...",
      "payload": {
        "context": { "type": "review_session", "id": "session_xyz" },
        "interactionType": "srs_review_submit",
        "details": {
          "progressId": "65d...",
          "lessonId": "64c...",
          "performanceScore": 4,
          "showAnswerDurationMs": 3450
        }
      }
    }
    ```

*   **`audio_preset_change`**
    *   **Trigger:** User manually selects a new preset or toggles playback in `BinauralPlayer`.
    *   **`details`:**
        *   `preset`: String | null (The key of the new preset, e.g., `"focus"`, `"creative"`, or `null` if stopped).
        *   `volume`: Number (Current volume level 0-1).
        *   `isPlaying`: Boolean (Current playback state).

    ```json
    {
      "type": "interaction",
      "timestamp": "...",
      "payload": {
        "context": { "type": "global", "id": null }, // Or specific lesson/subject context if applicable
        "interactionType": "audio_preset_change",
        "details": {
          "preset": "focus",
          "volume": 0.7,
          "isPlaying": true
        }
      }
    }
    ```

*   **`quiz_answer_submit`** (For AI Generated Quiz or Lesson Quizzes)
    *   **Trigger:** User submits an answer to a quiz question.
    *   **`details`:**
        *   `quizId`: String (Identifier for the quiz).
        *   `questionId`: String | Number (Identifier for the question within the quiz).
        *   `selectedOption`: String (e.g., "B").
        *   `isCorrect`: Boolean.
        *   `timeTakenMs`: Number (Optional: Time spent on the question).

    ```json
    {
      "type": "interaction",
      "timestamp": "...",
      "payload": {
        "context": { "type": "lesson", "id": "..." },
        "interactionType": "quiz_answer_submit",
        "details": {
          "quizId": "lesson_abc_quiz_1",
          "questionId": 2,
          "selectedOption": "C",
          "isCorrect": false,
          "timeTakenMs": 8700
        }
      }
    }
    ```

*   *(Future interaction types: `pattern_rec_attempt`, `focus_timer_event`, `scroll_depth`, `video_playback`)*
